(ns advent-of-code-2019.day-7
  "Solutions to the Day 7 problems"
  (:require [clojure.repl :refer :all]
            [clojure.math.combinatorics :as combo]
            [clojure.core.async :as a :refer [>! <! >!! <!!]]))

(def program
  "The intcode program data for day 7 part 1"
  [3,8,1001,8,10,8,105,1,0,0,21,34,43,64,85,98,179,260,341,422,99999,3,9,1001,9,3,9,102,3,9,9,4,9,99,3,9,
   102,5,9,9,4,9,99,3,9,1001,9,2,9,1002,9,4,9,1001,9,3,9,1002,9,4,9,4,9,99,3,9,1001,9,3,9,102,3,9,9,
   101,4,9,9,102,3,9,9,4,9,99,3,9,101,2,9,9,1002,9,3,9,4,9,99,3,9,101,1,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,
   102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,
   1001,9,1,9,4,9,3,9,101,2,9,9,4,9,3,9,1001,9,2,9,4,9,99,3,9,101,1,9,9,4,9,3,9,102,2,9,9,4,9,3,9,
   101,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,
   101,1,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,99,3,9,101,1,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,
   102,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,101,1,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,
   1001,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,101,1,9,9,4,9,99,3,9,101,1,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,
   102,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,
   101,1,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,1002,9,2,9,4,9,99,3,9,101,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,
   1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,
   1002,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,99])

(defn intcode
  "Run the day 7 intcode interpreter on the supplied program and input data, gathering output."
  ([input-data]
   (intcode program input-data))
  ([program-data input-data]
   (loop [pc      0                ; Program counter: address of next instruction to be executed.
          memory  program-data     ; The entire memory of the computer, initialized with the program contents.
          inputs  (seq input-data) ; The input values that were passed to the program.
          outputs []]              ; The output values that are generated by the program.
     (let [load-from-pc    (fn [offset] (nth memory (+ pc offset)))
           instruction     (load-from-pc 0)
           opcode          (rem instruction 100)
           modes           (clojure.string/reverse (str (quot instruction 100)))
           resolve-operand (fn [index]  ; Handles mode for a value being loaded, which can be immediate.
                             (let [value (load-from-pc (inc index))
                                   mode  (nth modes index \0)]
                               (case mode
                                 \0 (nth memory value)
                                 \1 value)))
           resolve-address (fn [index]  ; Handles mode for a value being stored, which can never be immediate.
                             (let [value (load-from-pc (inc index))
                                   mode  (nth modes index \0)]
                               (case mode  ; Still use a case statement so we can crash when given invalid modes.
                                 \0 value)))]
       #_(println "pc:" pc "opcode:" opcode "modes:" modes #_"mem:" #_memory)

       ;; Decode an instruction and compute appropriate new values for
       ;; the program counter, relative addressing mode base, memory,
       ;; and input and output lists.
       (case opcode

         ;; Add operand 0 to operand 1, storing the result in address specified by operand 2.
         1  (recur (+ pc 4)  ; Add
                   (assoc memory (load-from-pc 3) (+ (resolve-operand 0) (resolve-operand 1)))
                   inputs outputs)

         ;; Multiply operand 0 by operand 1, storing the result in address specified by operand 2.
         2  (recur (+ pc 4)  ; Multiply
                   (assoc memory (load-from-pc 3) (* (resolve-operand 0) (resolve-operand 1)))
                   inputs outputs)

         ;; Read an input value, storing it in the address specified by operand 0.
         3  (recur (+ pc 2)  ; Read
                   (assoc memory (load-from-pc 1) (first inputs))
                   (rest inputs) outputs)

         ;; Output the value specified by operand 0.
         4  (recur (+ pc 2)  ; Print
                   memory inputs (conj outputs (resolve-operand 0)))

         ;; If the value of operand 0 is true (non-zero) jump to the address found in operand 1.
         5  (recur (if (zero? (resolve-operand 0))  ; Jump if true
                     (+ pc 3)
                     (resolve-operand 1))
                   memory inputs outputs)

         ;; If the value of operand 0 is false (zero) jump to the address found in operand 1.
         6  (recur (if (zero? (resolve-operand 0))  ; Jump if false
                     (resolve-operand 1)
                     (+ pc 3))
                   memory inputs outputs)

         ;; Store a 1 in the address specified by operand 2 if operand 0 is less than operand 1, otherwise store a 0.
         7  (recur (+ pc 4)  ; Less than
                   (assoc memory (load-from-pc 3)
                          (if (< (resolve-operand 0) (resolve-operand 1)) 1 0))
                   inputs outputs)

         ;; Store a 1 in the address specified by operand 2 if operand 0 equals operand 1, otherwise store a 0.
         8  (recur (+ pc 4)  ; Equals
                   (assoc memory (load-from-pc 3)
                          (if (= (resolve-operand 0) (resolve-operand 1)) 1 0))
                   inputs outputs)

         ;; End the program, returning the output vector.
         99 outputs)))))

(defn try-settings
  "Run a chain of amplifiers with the supplied phase settings,
  returning the final amplifier's output."
  [program-data settings]
  (loop [result    0
         remaining settings]
    (if (seq remaining)
      (recur (first (intcode program-data [(first remaining) result]))
             (rest remaining))
      result)))

(defn find-optimal-settings
  "Try all phase permutations and return the best, as well as its
  resulting thrust."
  ([]
   (find-optimal-settings program))
  ([program-data]
   (let [all-settings (combo/permutations [0 1 2 3 4])]
     (loop [result    [(vec (first all-settings)) (try-settings program-data (first all-settings))]
            remaining (rest all-settings)]
       (if (seq remaining)
         (let [settings (first remaining)
               signal   (try-settings program-data settings)
               best     (if (> signal (nth result 1))
                          [settings signal]
                          result)]
           (recur best (rest remaining)))
         result)))))

;; Part 2

(defn intcode-async
  "Asynchronous version of the extended intcode interpreter, reading
  inputs from a channel, and writing outputs to another. Indicates
  program termination by closing the output channel."
  ([input-chan output-chan]
   (intcode-async program input-chan output-chan))
  ([program-data input-chan output-chan]
   (a/go-loop [pc      0  ; Program counter: address of next instruction to be executed.
               memory  program-data]  ; The entire memory of the computer, initialized with the program contents.
     (let [load-from-pc    (fn [offset] (nth memory (+ pc offset)))
           instruction     (load-from-pc 0)
           opcode          (rem instruction 100)
           modes           (clojure.string/reverse (str (quot instruction 100)))
           resolve-operand (fn [index]  ; Handles mode for a value being loaded, which can be immediate.
                             (let [value (load-from-pc (inc index))
                                   mode  (nth modes index \0)]
                               (case mode
                                 \0 (nth memory value)
                                 \1 value)))
           resolve-address (fn [index]  ; Handles mode for a value being stored, which can never be immediate.
                             (let [value (load-from-pc (inc index))
                                   mode  (nth modes index \0)]
                               (case mode  ; We still use case so we can crash if we get an invalid mode.
                                 \0 value)))]

       ;; Decode an instruction and compute appropriate new values for
       ;; the program counter, relative addressing mode base, memory,
       ;; and perform I/O on the input/output channels when needed.
       (case opcode

         ;; Add operand 0 to operand 1, storing the result in address specified by operand 2.
         1  (recur (+ pc 4)
                   (assoc memory (load-from-pc 3) (+ (resolve-operand 0) (resolve-operand 1))))

         ;; Multiply operand 0 by operand 1, storing the result in address specified by operand 2.
         2  (recur (+ pc 4)
                   (assoc memory (load-from-pc 3) (* (resolve-operand 0) (resolve-operand 1))))

         ;; Read an input value, storing it in the address specified by operand 0.
         3  (recur (+ pc 2)
                   (assoc memory (load-from-pc 1) (<! input-chan)))

         ;; Output the value specified by operand 0.
         4  (recur (+ pc 2)
                   (do
                     (>! output-chan (resolve-operand 0))
                     memory))

         ;; If the value of operand 0 is true (non-zero) jump to the address found in operand 1.
         5  (recur (if (zero? (resolve-operand 0))
                     (+ pc 3)
                     (resolve-operand 1))
                   memory)

         ;; If the value of operand 0 is false (zero) jump to the address found in operand 1.
         6  (recur (if (zero? (resolve-operand 0))
                     (resolve-operand 1)
                     (+ pc 3))
                   memory)

         ;; Store a 1 in the address specified by operand 2 if operand 0 is less than operand 1, otherwise store a 0.
         7  (recur (+ pc 4)
                   (assoc memory (load-from-pc 3)
                          (if (< (resolve-operand 0) (resolve-operand 1)) 1 0)))

         ;; Store a 1 in the address specified by operand 2 if operand 0 equals operand 1, otherwise store a 0.
         8  (recur (+ pc 4)
                   (assoc memory (load-from-pc 3)
                          (if (= (resolve-operand 0) (resolve-operand 1)) 1 0)))

         ;; End the program, closing the output channel.
         99 (a/close! output-chan))))))

(defn async-try-settings
  "Run a chain of async amplifiers with the supplied phase settings,
  returning the final amplifier's output."
  ([settings]
   (async-try-settings program))
  ([program-data settings]
   ;; Set up the channels that will feed the output of one amplifier to
   ;; the input of the next, and a final output channel that the main
   ;; loop will use to track values coming out and feed them back in to
   ;; the first amplifier.
   (let [input-channels (mapv (fn [phase] (let [result (a/chan 5)]
                                            (>!! result phase)
                                            result))
                              settings)
         first-input    (nth input-channels 0)
         last-output    (a/chan 5)]
     (dotimes [i (count input-channels)]
       (intcode-async program-data (nth input-channels i) (nth input-channels (inc i) last-output)))
     (>!! first-input 0)  ; Send seed value to first amplifier in the chain.
     ;; Run the feedback loop until the last amplifier shuts down, returning its final output value.
     (loop [result nil
            latest (<!! last-output)]
       (if latest
         (do
           (>!! first-input latest)
           (recur latest (<!! last-output)))
         result)))))

(defn async-find-optimal-settings
  "Try all phase permutations of the async amplifier configuration and
  return the best, as well as its resulting thrust."
  ([]
   (async-find-optimal-settings program))
  ([program-data]
   (loop [result    [[] 0]
          remaining (combo/permutations [5 6 7 8 9])]
     (if (seq remaining)
       (let [settings (first remaining)
             signal   (async-try-settings program-data settings)
             best     (if (> signal (nth result 1))
                        [settings signal]
                        result)]
         #_(println "best so far:" best)
         (recur best (rest remaining)))
       result))))
